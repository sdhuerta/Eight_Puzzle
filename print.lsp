(defun rowState (puzzleStates puzzleSize)
  ;12 is an arbitrary number to represent column width
  (let ((L '()) (rowStates '()) (statesPerRow (floor (/ 12 puzzleSize))))
    (dotimes (i (length puzzleStates))
      (if (and (not(eq i 0)) (eq 0 (mod i statesPerRow)))
        (progn (push (reverse L) rowStates) (setf L nil) (push (nth i puzzleStates) L))
        (push (nth i puzzleStates) L)
      )
    )
    (push (reverse L) rowStates)
    (setf rowStates (reverse rowStates)) 
  )
)

(defun printPuzzle (name puzzleStates moveCount genNodes disNodes exNodes puzzleSize)  
  (let ((rowStates (rowState puzzleStates puzzleSize)) (j 0))
    (format t "~a~%" name)
    (format t "---------------~%")
    (format t "Solution found in ~d moves~%" moveCount)
    (format t "~d nodes generated (~d distinct nodes), ~d nodes expanded~%~%" genNodes disNodes exNodes)
    (dolist (row rowStates)
      ;(write "Row: ")
      ;(write row)
      ;(format t "~%")
      (dotimes (i puzzleSize)
        (dolist (state row)
          (do ((k j (1+ k)))
	       ((= k (+ j puzzleSize)))
              (if (eq 0 (nth k state))
                (format t "  ")
                (format t "~d " (nth k state))
              )
	  )
          (format t "     ")
        )
        (format t "~%")
        (setf j (+ j puzzleSize))
      )  
      (format t "~%")
      (setf j 0)
    )
  )
)

(setf puzzleStates '((2 8 3 1 6 0 7 5 4) (2 8 3 1 6 4 7 5 0) (2 8 3 1 6 4 7 0 5) (2 8 3 1 0 4 7 6 5) (2 0 3 1 8 4 7 6 5) (0 2 3 1 8 4 7 6 5) (1 2 3 0 8 4 7 6 5) (1 2 3 8 0 4 7 6 5)))

(printPuzzle "BFS" puzzleStates 10 11 12 13 3)

